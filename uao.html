<h1>UaObjects library</h1><br><h2>Purpose</h2>The UaObjects maps OPC-UA objects (as seen in server's address space) into Python objects.<br>Thanks to this, you can access OPC-UA data and methods exactly like it were fields and methods of "local" Python objects.<br>This helps to remove a lot of boiler-plate code and enables to implement distributed-object over OPC-UA and other functionalities.<br><br><h2>Requirements</h2>Currently, PyUaf is used as a provider of OPC-UA connectivity.<br><br><h2>Basic example (example1)<br></h2>The example1 is available as example1.py<br>Import PyUaf and open an OPC-UA session:<br><br><pre><br>from pyuaf.client           import Client<br>from pyuaf.client.settings  import ClientSettings, SessionSettings<br>from pyuaf.util             import Address, NodeId, opcuaidentifiers<br>import uao<br><br>server_uri = 'urn:CERN:QuasarOpcUaServer'  # needs to match the factual server URI<br>server_address = 'opc.tcp://127.0.0.1:4841'<br>cs = ClientSettings("myClient", [server_address])<br>client = Client(cs)<br># next 2 lines are not necessary but help to ensure good state of OPC-UA connectivity<br>rootNode = Address( NodeId(opcuaidentifiers.OpcUaId_RootFolder, 0), server_uri )<br>result=client.browse ([ rootNode ])<br><br></pre>Create UaObjects Session - it will be your entry point to get your mapped OPC-UA objects. Pay attention <br><br><pre>session = uao.Session(client, server_uri )<br></pre>Get an object by string address and namespace identifier:<br><pre>obj = session.get_object('anObject', 2)  # needs to match factuall existing object<br><br></pre>Now your object obj is mapped into OPC-UA object residing at address "tc", namespace index 2. You can:<br><ol><li>call remote methods bound to the object, i.e.:<br><pre>obj.myMethodName(1,2,3)</pre></li><li>write fields of the object, i.e.:<br><pre>obj.variable.value = Int32( 12345 )&nbsp; # Int32 is from pyuaf.util.primitives.Int32, import it</pre></li><li>read fields of the object (currently direct read supported only, work for subscriptions in progress):<br><pre>print obj.variable.value&nbsp; # will call OPC-UA read transaction and print out returned value</pre></li><li>all of the above with objects referred to using "HasComponent" relation, with unlimited recurrence depth, i.e.:<br><pre>print obj.subObject.variable.value&nbsp; # will find an object with a browse name "subObject" referred from object "obj", and then print out the value of variable "variable"</pre></li></ol>Any errors will be thrown.<br>